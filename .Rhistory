#'
#' @examples
#' a <- new.env()
#' a$x <- 1
#' a$y <- "hello"
#' a$z <- data.frame(x = runif(20))
#'
#' b <- copy_env(a)
#' identical(a$z,b$z)
#' rlang::env_label(a) == rlang::env_label(b)
#'
#' f1 <- . %>%
#'         magrittr::add(2) %>%
#'         magrittr::multiply_by(2)
#' f2 <- f1
#' f3 <- copy_fun(f1)
#'
#' f1_env_label <- rlang::env_label(rlang::get_env(f1))
#' f2_env_label <- rlang::env_label(rlang::get_env(f2))
#' f3_env_label <- rlang::env_label(rlang::get_env(f3))
#' f1_env_label == f2_env_label
#' f1_env_label == f3_env_label
#'
#'
copy_env <- function(env)
{
obj_list <- ls(env)
new_env <- rlang::new_environment(parent=parent.env(env))
obj_list
for(c_obj in obj_list)
{
if(is.environment(env[[c_obj]]))
{
new_env[[c_obj]] <- copy_env(env[[c_obj]])
} else
{
new_env[[c_obj]] <- env[[c_obj]]
}
}
new_env
}
#' @rdname copy_env
#' @export
#'
copy_fun <- function(fun)
{
if(is_fseq(fun))
{
new_fun <- fseq_copy_env(fun)
} else if(is_function(fun))
{
new_fun <- fun
environment(new_fun) <- copy_env(environment(fun))
}
new_fun
}
#' @name fseq_methods
#'
#' @title
#' Generic methods for fseq manipulations
#'
#' @description
#' When pipelines are created without an initial term, the
#' \code{\link{magrittr}} package (where the pipes originate)
#' creates a specialised type of function called a \code{fseq}.
#' However, \code{\link{magrittr}} doesn't do much with these
#' \code{fseq} objects.
#'
#' @examples
#' a <- . %>% add(2) %>% divide_by(3)
#' b <- . %>% rep(3) %>% sum
#'
#' a + b
#'
#' (a+b)(2)
#' (b+a)(2)
#'
#'
#' @export
`+.fseq` <- function(lhs,rhs)
{
y <- lhs
environment(y) <- new.env(parent=parent.env(environment(lhs)))
environment(y)[["_function_list"]] <- c(magrittr::functions(lhs),
magrittr::functions(rhs))
y
}
#' @rdname fseq_methods
#' @export
#'
#' @examples
#' length(a)
length.fseq <- function(x)
{
length(magrittr::functions(x))
}
#' @rdname fseq_methods
#' @export
#'
#' @examples
#' is.fseq(a)
#'
is.fseq <- function(x)
{
"fseq" %in% class(x)
}
#' @rdname fseq_methods
#' @export
#'
#' @examples
#' is_fseq(a)
#'
is_fseq <- function(x)
{
"fseq" %in% class(x)
}
reinstall_my_package()
library(mutils)
reinstall_my_package()
unload("mutils")
devtools::load_all()
rm(list=ls())
iris %>%
tibble %>%
select(Species,Sepal.Length,Sepal.Width) %>%
pipe_qplot(Sepal.Length,Sepal.Width,col=Species)
#' @name pipe_qplot
#'
#' @title
#' Pipe-able version of the `qplot()`
#'
#' @description
#' The [`qplot()`][ggplot2::qplot()] function is traditionally used
#' when your data is not stored in a data.frame/tibble and are
#' "loose" within your environment and can be convenient if you are
#' familiar with the base [`plot()`][base::plot()], but haven't quite
#' learned the grammar of `ggplot2`.
#' It is a wrapper that creates a [`ggplot()`][ggplot2::ggplot()]
#' style plot.
#'
#' However, creating a [`ggplot()`][ggplot2::ggplot()] object can be
#' complex and inconvenient, especially if you want a simple plot
#' (e.g. a basic histogram). It also requires you to either break
#' out of a pipeline, or ensure your [`ggplot()`][ggplot2::ggplot()]
#' functions are at the end of a pipe (or introduce curly braces
#' `{}` to your pipeline).
#'
#' Therefore, the `pipe_qplot()` function will run a
#' [`qplot()`][ggplot2::qplot()] function for it's side effects and
#' return your original input unchanged. It can also save your plot
#' if needed.
#'
#' @param data
#' the data being passed through the pipeline
#'
#' @param x,y,...
#' aesthetic arguments to be passed to the [`qplot()`][ggplot2::qplot()] function
#'
#' @param save.options
#' list of values to be passed to [`ggsave()`][ggplot2::ggsave()]
#' (if NULL, plot won't be saved)
#'
#' @param print.plot
#' should the plot be displayed? Should only be used if
#' `save.options` is not NULL
#'
#' @param  facets,margins,geom,xlim,ylim,log,main,xlab,ylab,asp,stat,position
#' see the [`qplot()`][ggplot2::qplot()] documentation for more
#' information regarding these arguments.
#'
#' @export
#'
#' @examples
#'
#' tibble::tibble(iris) %>%
#'   dplyr::group_by(Species) %>%
#'   pipe_qplot(Sepal.Length,
#'              fill=Species,
#'              geom="histogram",
#'              binwidth=0.1) %>%
#'   dplyr::summarise(mean = mean(Sepal.Length))
#'
#'
#'
pipe_qplot <- function(data, x, y, ..., facets = NULL, margins = FALSE, geom = "auto",
xlim = c(NA, NA), ylim = c(NA, NA),log = "",
main = NULL, xlab = NULL, ylab = NULL, asp = NA,
save.options = NULL, print.plot = T)
{
if(is.null(save.options) & !print.plot)
{
rlang::warn("print.plot set to FALSE in pipe_qplot() &
no save.options supplied. Nothing done")
} else {
parent <- parent.frame()
env <- new.env(parent = parent)
.call <- match.call()
.args <- names(.call)
if(any(.args %in% c("print.plot","save.options","data")))
.call <- .call[-which(.args %in% c("print.plot","save.options","data"))]
.call[[1]] <- quote(qplot)
p <- eval_expr(.call,data)
if(print.plot)
print(p)
if(!is.null(save.options))
{
if(any(names(save.options) == "plot"))
save.options <- save.options[-which(names(save.options) == "plot")]
save.call <- as.call(c(quote(ggsave),save.options,plot=quote(p)))
eval(save.call)
}
}
return(data)
}
iris %>%
tibble %>%
select(Species,Sepal.Length,Sepal.Width) %>%
pipe_qplot(Sepal.Length,Sepal.Width,col=Species)
library(mutils)
#' @name eval_expr
#'
#' @title
#' Evaluates an expression within a data context
#'
#' @description
#' Uses the [eval_tidy()][rlang::eval_tidy()] function to evaluate an expression
#' within the context of the `data` and `env` arguments.
#' It provides two additional elements of flexibility:
#' * `data` does not need to be named, if it isn't named, it can be
#'   references by `.` or `.data`.
#' * `expr` can be a function (preferably a `fseq` object)
#'   that will be applied to `data`. What's more is that `expr`
#'   will be evaluated through `eval_tidy()` before being applied
#'   and so functions defined within `data` can also be used.
#'
#' Note the `data` argument is first (whereas in `eval_tidy()`, it is
#' second) to keep in line with the pipeline theme of `mpipe`.
#'
#' @param data
#' data within which to evaluate. Used as a data mask in `eval_tidy()`
#'
#'
#' @param expr
#' a call, function or expression to be evaluated within the context
#' of `data`
#'
#' @param ...
#' additional arguments to be attached to `data` during evaluation.
#'
#' @param env
#' the environment in which to evaluate the expression
#'
#' @param allow_NULL
#' logical. Can `eval_expr()` return a `NULL` value? By default, `NULL`s will
#' result in an error.
#'
#' @param verbose
#' logical. Should `eval_expr()` be chatty?
#'
#' @examples
#'
#' #Can do simple evaluations of functions on vectors
#' 1:10 %>% eval_expr(mean)
#'
#' #Or on a variable
#' x <- 1:10
#' eval_expr(x,mean)
#'
#' #or within a data.frame (or tibble)
#' tbl <- data.frame(x=1:10)
#' eval_expr(tbl,mean(x))
#'
#' #or a list
#' lst <- list(x=1:10)
#' eval_expr(lst,mean(x))
#'
#' #functions are applied to data
#' eval_expr(tbl,nrow)
#'
#' #but they are evaluated within data first
#' lst <- c(fun=mean,lst)
#' eval_expr(lst,fun(x))
#'
#' #additional named arguments can be passed in too
#' tbl %>%
#'   eval_expr(mean(x+y),y=5)
#'
#' x %>%
#'   eval_expr(. %>% add(y) %>% mean,y=5)
#'
#'
#' #Environment scope:
#' lst <- list(x=1:3,y=1)
#' y <- 4
#'
#' e1 <- new.env(parent=emptyenv())
#' e1$y <- 3
#'
#' #additional arguments in data take priority over others
#' eval_expr(lst,y,y=2,env=e1)
#'
#' lst$y <- NULL
#' # then the ... argument:
#' eval_expr(lst,y,y=2,env=e1)
#'
#' #then in env
#' eval_expr(lst,y,env=e1)
#'
#' #without env, the calling environment is used
#' eval_expr(lst,y)
#'
#'
#'
eval_expr <- function(data,expr,...,env=NULL,allow_NULL=F,verbose=F)
{
cat0 <- nutils::chatty(verbose)
if(is.null(env))
{
cat0("No environment provided, so the caller environment is used")
env <- rlang::caller_env()
}
cat0("Quoting expr")
quo_expr <- enquo(expr)
if(!rlang::is_named(data))
{
cat0("data doesn't have names, so it will be wrapped in a list")
named_data <- list(. = data,.data=data,.env=env)
} else
{
cat0("data has names")
named_data <- as.list(data,.=data,.data=data,.env=env)
}
cat0("Checking for `...`")
dots <- dots_list(...,.homonyms = "first")
dot_nms <- names(dots)
dots <- dots[dot_nms != "" & !is.environment(dots)]
if(length(dots) > 0)
{
cat0("Input has usable `...` argument")
named_data <-c(named_data,dots[!names(dots) %in% names(named_data)])
}
cat0("Setting the environment of the quoted expr")
quo_expr <- rlang::quo_set_env(quo_expr,env)
cat0("Evaluating with eval_tidy()")
res <- eval_tidy(quo_expr,named_data,env)
if(is.function(res))
{
cat0("Output was a function, so it will be applied to the data")
res <- res(data)
}
if(!allow_NULL && is.null(res))
{
rlang::abort("eval_expr() returning NULL. Should this be allowed?")
}
cat0("Thanks for listening")
res
}
iris %>%
tibble %>%
select(Species,Sepal.Length,Sepal.Width) %>%
pipe_qplot(Sepal.Length,Sepal.Width,col=Species)
#' @name eval_expr
#'
#' @title
#' Evaluates an expression within a data context
#'
#' @description
#' Uses the [eval_tidy()][rlang::eval_tidy()] function to evaluate an expression
#' within the context of the `data` and `env` arguments.
#' It provides two additional elements of flexibility:
#' * `data` does not need to be named, if it isn't named, it can be
#'   references by `.` or `.data`.
#' * `expr` can be a function (preferably a `fseq` object)
#'   that will be applied to `data`. What's more is that `expr`
#'   will be evaluated through `eval_tidy()` before being applied
#'   and so functions defined within `data` can also be used.
#'
#' Note the `data` argument is first (whereas in `eval_tidy()`, it is
#' second) to keep in line with the pipeline theme of `mpipe`.
#'
#' @param data
#' data within which to evaluate. Used as a data mask in `eval_tidy()`
#'
#'
#' @param expr
#' a call, function or expression to be evaluated within the context
#' of `data`
#'
#' @param ...
#' additional arguments to be attached to `data` during evaluation.
#'
#' @param env
#' the environment in which to evaluate the expression
#'
#' @param allow_NULL
#' logical. Can `eval_expr()` return a `NULL` value? By default, `NULL`s will
#' result in an error.
#'
#' @param verbose
#' logical. Should `eval_expr()` be chatty?
#'
#' @examples
#'
#' #Can do simple evaluations of functions on vectors
#' 1:10 %>% eval_expr(mean)
#'
#' #Or on a variable
#' x <- 1:10
#' eval_expr(x,mean)
#'
#' #or within a data.frame (or tibble)
#' tbl <- data.frame(x=1:10)
#' eval_expr(tbl,mean(x))
#'
#' #or a list
#' lst <- list(x=1:10)
#' eval_expr(lst,mean(x))
#'
#' #functions are applied to data
#' eval_expr(tbl,nrow)
#'
#' #but they are evaluated within data first
#' lst <- c(fun=mean,lst)
#' eval_expr(lst,fun(x))
#'
#' #additional named arguments can be passed in too
#' tbl %>%
#'   eval_expr(mean(x+y),y=5)
#'
#' x %>%
#'   eval_expr(. %>% add(y) %>% mean,y=5)
#'
#'
#' #Environment scope:
#' lst <- list(x=1:3,y=1)
#' y <- 4
#'
#' e1 <- new.env(parent=emptyenv())
#' e1$y <- 3
#'
#' #additional arguments in data take priority over others
#' eval_expr(lst,y,y=2,env=e1)
#'
#' lst$y <- NULL
#' # then the ... argument:
#' eval_expr(lst,y,y=2,env=e1)
#'
#' #then in env
#' eval_expr(lst,y,env=e1)
#'
#' #without env, the calling environment is used
#' eval_expr(lst,y)
#'
#'
#'
eval_expr <- function(data,expr,...,env=NULL,allow_NULL=F,verbose=F)
{
cat0 <- mutils::chatty(verbose)
if(is.null(env))
{
cat0("No environment provided, so the caller environment is used")
env <- rlang::caller_env()
}
cat0("Quoting expr")
quo_expr <- enquo(expr)
if(!rlang::is_named(data))
{
cat0("data doesn't have names, so it will be wrapped in a list")
named_data <- list(. = data,.data=data,.env=env)
} else
{
cat0("data has names")
named_data <- as.list(data,.=data,.data=data,.env=env)
}
cat0("Checking for `...`")
dots <- dots_list(...,.homonyms = "first")
dot_nms <- names(dots)
dots <- dots[dot_nms != "" & !is.environment(dots)]
if(length(dots) > 0)
{
cat0("Input has usable `...` argument")
named_data <-c(named_data,dots[!names(dots) %in% names(named_data)])
}
cat0("Setting the environment of the quoted expr")
quo_expr <- rlang::quo_set_env(quo_expr,env)
cat0("Evaluating with eval_tidy()")
res <- eval_tidy(quo_expr,named_data,env)
if(is.function(res))
{
cat0("Output was a function, so it will be applied to the data")
res <- res(data)
}
if(!allow_NULL && is.null(res))
{
rlang::abort("eval_expr() returning NULL. Should this be allowed?")
}
cat0("Thanks for listening")
res
}
iris %>%
tibble %>%
select(Species,Sepal.Length,Sepal.Width) %>%
pipe_qplot(Sepal.Length,Sepal.Width,col=Species)
library(mutils)
reload_packages("mutils")
iris %>%
tibble %>%
select(Species,Sepal.Length,Sepal.Width) %>%
pipe_qplot(Sepal.Length,Sepal.Width,col=Species)
library(mutils)
library(mutils)
chatty()
