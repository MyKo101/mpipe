% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_expr.R
\name{eval_expr}
\alias{eval_expr}
\title{Evaluates an expression within a data context}
\usage{
eval_expr(data, expr, ..., env = NULL, allow_NULL = F, verbose = F)
}
\arguments{
\item{data}{data within which to evaluate. Used as a data mask in \code{eval_tidy()}}

\item{expr}{a call, function or expression to be evaluated within the context
of \code{data}}

\item{...}{additional arguments to be attached to \code{data} during evaluation.}

\item{env}{the environment in which to evaluate the expression}

\item{allow_NULL}{logical. Can \code{eval_expr()} return a \code{NULL} value? By default, \code{NULL}s will
result in an error.}

\item{verbose}{logical. Should \code{eval_expr()} be chatty?}
}
\description{
Uses the \link[rlang:eval_tidy]{eval_tidy()} function to evaluate an expression
within the context of the \code{data} and \code{env} arguments.
It provides two additional elements of flexibility:
\itemize{
\item \code{data} does not need to be named, if it isn't named, it can be
references by \code{.} or \code{.data}.
\item \code{expr} can be a function (preferably a \code{fseq} object)
that will be applied to \code{data}. What's more is that \code{expr}
will be evaluated through \code{eval_tidy()} before being applied
and so functions defined within \code{data} can also be used.
}

Note the \code{data} argument is first (whereas in \code{eval_tidy()}, it is
second) to keep in line with the pipeline theme of \code{mpipe}.
}
\examples{

#Can do simple evaluations of functions on vectors
1:10 \%>\% eval_expr(mean)

#Or on a variable
x <- 1:10
eval_expr(x,mean)

#or within a data.frame (or tibble)
tbl <- data.frame(x=1:10)
eval_expr(tbl,mean(x))

#or a list
lst <- list(x=1:10)
eval_expr(lst,mean(x))

#functions are applied to data
eval_expr(tbl,nrow)

#but they are evaluated within data first
lst <- c(fun=mean,lst)
eval_expr(lst,fun(x))

#additional named arguments can be passed in too
tbl \%>\%
  eval_expr(mean(x+y),y=5)

x \%>\%
  eval_expr(. \%>\% magrittr::add(y) \%>\% mean,y=5)


#Environment scope:
lst <- list(x=1:3,y=1)
y <- 4

e1 <- new.env(parent=emptyenv())
e1$y <- 3

#additional arguments in data take priority over others
eval_expr(lst,y,y=2,env=e1)

lst$y <- NULL
# then the ... argument:
eval_expr(lst,y,y=2,env=e1)

#then in env
eval_expr(lst,y,env=e1)

#without env, the calling environment is used
eval_expr(lst,y)



}
